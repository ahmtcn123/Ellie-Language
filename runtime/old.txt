        pub fn loop_item(
            thread: &mut thread::Thread,
            item: definite::items::Collecting,
            page_id: u64,
        ) -> Option<(usize, bool)> {
            let current_pages_len = thread.pages.len();
            match item {
                definite::items::Collecting::ImportItem(import_item) => {
                    if !thread
                        .pages
                        .contains_key(&(import_item.resolution_id as u64))
                    {
                        thread.pages.insert(
                            import_item.resolution_id.clone() as u64,
                            thread::Page {
                                page_id: import_item.resolution_id as u64,
                                headers: BTreeMap::new(),
                                heap: heap::Heap::new(),
                                stack: stack::Stack::new(import_item.resolution_id.clone() as usize),
                                step: 0,
                            },
                        );
                    }

                    std::println!(
                        "IMPORTING: from {}, id: {:#04x}, current: {:#04x}- from_id: {:#04x}",
                        import_item.from_path,
                        import_item.resolution_id,
                        import_item.from_import,
                        page_id
                    );

                    let ret = loop_item(thread, *import_item.item, import_item.resolution_id);
                    if let Some(element_id) = ret {
                        match thread.pages.get_mut(&page_id) {
                            Some(page) => {
                                if element_id.1 {
                                    page.stack.register_reference(import_item.resolution_id as usize, element_id.0);
                                }
                            }
                            None => panic!("UNEXPECTED RUNTIME BEHAVIOUR"),
                        }
                    }
                    ret
                }
                definite::items::Collecting::Import(import) => {
                    if !thread.pages.contains_key(&import.id) {
                        thread.pages.insert(
                            import.id as u64,
                            thread::Page {
                                page_id: import.id as u64,
                                headers: BTreeMap::new(),
                                heap: heap::Heap::new(),
                                stack: stack::Stack::new(import.id as usize),
                                step: 0,
                            },
                        );
                    }
                    None
                }
                definite::items::Collecting::Variable(variable) => {
                    let type_name = match variable.rtype {
                        definite::definers::DefinerCollecting::Array(_) => "array".to_owned(),
                        definite::definers::DefinerCollecting::Future(_) => "future".to_owned(),
                        definite::definers::DefinerCollecting::GrowableArray(_) => {
                            "growableArray".to_owned()
                        }
                        definite::definers::DefinerCollecting::Generic(e) => e.rtype,
                        definite::definers::DefinerCollecting::Function(_) => "function".to_owned(),
                        definite::definers::DefinerCollecting::Cloak(_) => "cloak".to_owned(),
                        definite::definers::DefinerCollecting::Collective(_) => {
                            "collective".to_owned()
                        }
                        definite::definers::DefinerCollecting::Nullable(_) => "nullAble".to_owned(),
                        definite::definers::DefinerCollecting::Dynamic => "dyn".to_owned(),
                    };

                    pub fn dumper(thread: &thread::Thread) -> String {
                        let mut dump_data = "\r\n---\n\r".to_owned();
                        let mut stack_dump = String::new();
                        for stack in thread.pages.clone() {
                            let mut headers = String::new();

                            for item in stack.1.headers {
                                headers += &format!("\t\t\t{:#04x} : {}\n", item.0, item.1)
                            }

                            stack_dump += &format!(
                                "\t---\n\tPage {:#04x}:\n\t\tHeaders:\n{}\n\t\tStack:\n\t{}\n\t\tHEAP:\n{}\n",
                                stack.0,
                                headers,
                                stack.1.stack.dump(),
                                stack.1.heap.clone().dump()
                            );
                        }

                        dump_data += &format!("Pages:\n{}\n\t---", stack_dump);
                        dump_data
                    }

                    let copy_dump = dumper(&*thread);
                    let type_id = thread.look_up_for_item_by_name(&type_name, page_id);
                    match thread.pages.get_mut(&page_id) {
                        Some(page) => match type_id {
                            Some(type_element) => {
                                let rtype = match type_element {
                                    stack::StackElements::Class(class) => {
                                        stack::StackElement::Type(class.id)
                                    }
                                    stack::StackElements::Generic(generic) => {
                                        stack::StackElement::Generic(generic.id)
                                    }
                                    _ => panic!("Unexpected runtime behaviour"),
                                };

                                let element_id = page.stack.register_variable(
                                    rtype,
                                    Some(
                                        add_data_to_heap(&mut page.heap, variable.value).clone()
                                            - 1,
                                    ),
                                    variable.dynamic,
                                );
                                page.headers.insert(element_id, variable.name);
                                Some((element_id, variable.public))
                            }
                            None => {
                                pub fn dumper(thread: &thread::Thread) -> String {
                                    let mut dump_data = "\r\n---\n\r".to_owned();
                                    let mut stack_dump = String::new();
                                    for stack in thread.pages.clone() {
                                        let mut headers = String::new();

                                        for item in stack.1.headers {
                                            headers +=
                                                &format!("\t\t\t{:#04x} : {}\n", item.0, item.1)
                                        }

                                        stack_dump += &format!(
                                            "\t---\n\tPage {:#04x}:\n\t\tHeaders:\n{}\n\t\tStack:\n\t{}\n\t\tHEAP:\n{}\n",
                                            stack.0,
                                            headers,
                                            stack.1.stack.dump(),
                                            stack.1.heap.clone().dump()
                                        );
                                    }

                                    dump_data += &format!("Pages:\n{}\n\t---", stack_dump);
                                    dump_data
                                }

                                panic!(
                                    "?? {:#?}, {:#?} - {:#04x}\n\nDUMP: {}",
                                    type_id, &type_name, page_id as u64, copy_dump
                                );
                                panic!("UNEXPECTED RUNTIME ERROR");
                            }
                        },
                        None => panic!("UNEXPECTED RUNTIME ERROR: CANNOT FIND PAGE"),
                    }
                }
                definite::items::Collecting::Function(function) => {
                    let next_page_id = current_pages_len + 1;
                    let mut child_headers: BTreeMap<usize, String> = BTreeMap::new();
                    let mut child_stack = stack::Stack::new(next_page_id);
                    let mut params: Vec<(usize, stack::StackElement)> = Vec::new();

                    for (id, parameter) in function.parameters.into_iter().enumerate() {
                        child_headers.insert(id, parameter.name.clone());

                        let raw_param_type = match parameter.rtype {
                            definite::definers::DefinerCollecting::Array(_) => "array".to_owned(),
                            definite::definers::DefinerCollecting::Future(_) => "future".to_owned(),
                            definite::definers::DefinerCollecting::GrowableArray(_) => {
                                "growableArray".to_owned()
                            }
                            definite::definers::DefinerCollecting::Generic(e) => e.rtype,
                            definite::definers::DefinerCollecting::Function(_) => {
                                "function".to_owned()
                            }
                            definite::definers::DefinerCollecting::Cloak(_) => "cloak".to_owned(),
                            definite::definers::DefinerCollecting::Collective(_) => {
                                "collective".to_owned()
                            }
                            definite::definers::DefinerCollecting::Nullable(_) => {
                                "nullAble".to_owned()
                            }
                            definite::definers::DefinerCollecting::Dynamic => "dyn".to_owned(),
                        };

                        pub fn dumper(thread: &thread::Thread) -> String {
                            let mut dump_data = "\r\n---\n\r".to_owned();
                            let mut stack_dump = String::new();
                            for stack in thread.pages.clone() {
                                let mut headers = String::new();

                                for item in stack.1.headers {
                                    headers += &format!("\t\t\t{:#04x} : {}\n", item.0, item.1)
                                }

                                stack_dump += &format!(
                                    "\t---\n\tPage {:#04x}:\n\t\tHeaders:\n{}\n\t\tStack:\n\t{}\n\t\tHEAP:\n{}\n",
                                    stack.0,
                                    headers,
                                    stack.1.stack.dump(),
                                    stack.1.heap.clone().dump()
                                );
                            }

                            dump_data += &format!("Pages:\n{}\n\t---", stack_dump);
                            dump_data
                        }

                        let copy_dump = &*thread;
                        let type_id = thread.look_up_for_item_by_name(&raw_param_type, page_id);
                        panic!(
                            "?? {:#?}, {:#?} - {:#04x}\n\nDUMP: {}",
                            type_id,
                            &raw_param_type,
                            page_id as u64,
                            dumper(copy_dump)
                        );
                        match type_id {
                            Some(type_element) => {
                                let rtype = match type_element {
                                    stack::StackElements::Class(class) => {
                                        stack::StackElement::Type(class.id)
                                    }
                                    stack::StackElements::Generic(generic) => {
                                        stack::StackElement::Generic(generic.id)
                                    }
                                    _ => panic!("Unexpected runtime behaviour"),
                                };
                                params.push((id, rtype.clone()));
                                child_stack.register_parameter(rtype);
                            }
                            None => panic!("UNEXPECTED RUNTIME ERROR"),
                        }

                        //
                    }

                    let raw_return_name = match function.return_type {
                        definite::definers::DefinerCollecting::Array(_) => "array".to_owned(),
                        definite::definers::DefinerCollecting::Future(_) => "future".to_owned(),
                        definite::definers::DefinerCollecting::GrowableArray(_) => {
                            "growableArray".to_owned()
                        }
                        definite::definers::DefinerCollecting::Generic(e) => e.rtype,
                        definite::definers::DefinerCollecting::Function(_) => "function".to_owned(),
                        definite::definers::DefinerCollecting::Cloak(_) => "cloak".to_owned(),
                        definite::definers::DefinerCollecting::Collective(_) => {
                            "collective".to_owned()
                        }
                        definite::definers::DefinerCollecting::Nullable(_) => "nullAble".to_owned(),
                        definite::definers::DefinerCollecting::Dynamic => "dyn".to_owned(),
                    };

                    let return_type_id =
                        thread.look_up_for_item_by_name(&raw_return_name, page_id as u64);

                    match return_type_id {
                        Some(type_element) => {
                            let return_rtype = match type_element {
                                stack::StackElements::Class(class) => {
                                    stack::StackElement::Type(class.id)
                                }
                                stack::StackElements::Generic(generic) => {
                                    stack::StackElement::Generic(generic.id)
                                }
                                _ => panic!("Unexpected runtime behaviour"),
                            };
                            match thread.pages.get_mut(&(page_id as u64)) {
                                Some(page) => {
                                    let element_id =
                                        page.stack.register_function(params, return_rtype);
                                    page.headers.insert(element_id, function.name);
                                }
                                None => panic!("UNEXPECTED RUNTIME ERROR: CANNOT FIND PAGE"),
                            }
                        }
                        None => panic!("UNEXPECTED RUNTIME ERROR"),
                    }

                    thread.pages.insert(
                        page_id as u64,
                        thread::Page {
                            page_id: page_id as u64,
                            headers: child_headers,
                            heap: heap::Heap::new(),
                            stack: child_stack,
                            step: page_id as usize,
                        },
                    );

                    //let page_id = current_pages_len + 1;
                    //let mut stack = stack::Stack::new(page_id);
                    //
                    //for parameter in function.parameters {
                    //    //Register function parameters in stack
                    //    //stack.register_parameter(parameter.rtype)
                    //}
                    None
                }
                definite::items::Collecting::ForLoop(_) => todo!(),
                definite::items::Collecting::Condition(_) => todo!(),
                definite::items::Collecting::Class(class) => match thread.pages.get_mut(&page_id) {
                    Some(page) => {
                        let mut class_items: Vec<definite::items::Collecting> =
                            vec![definite::items::Collecting::Constructor(class.constructor)];

                        class_items.extend(
                            class
                                .getters
                                .into_iter()
                                .map(|x| definite::items::Collecting::Getter(x))
                                .collect::<Vec<_>>(),
                        );

                        class_items.extend(
                            class
                                .setters
                                .into_iter()
                                .map(|x| definite::items::Collecting::Setter(x))
                                .collect::<Vec<_>>(),
                        );

                        class_items.extend(
                            class
                                .methods
                                .into_iter()
                                .map(|x| definite::items::Collecting::Function(x))
                                .collect::<Vec<_>>(),
                        );

                        class_items.extend(
                            class
                                .properties
                                .into_iter()
                                .map(|x| definite::items::Collecting::Variable(x))
                                .collect::<Vec<_>>(),
                        );

                        let page_id = current_pages_len + 1;

                        let mut generics = Vec::new();
                        let mut child_headers: BTreeMap<usize, String> = BTreeMap::new();
                        let mut child_stack = stack::Stack::new(page_id);
                        for (id, generic) in class.generic_definings.into_iter().enumerate() {
                            child_headers.insert(id, generic.name.clone());
                            generics.push(id);
                            child_stack.register_generic(id);
                        }

                        let element_id = page.stack.register_class(page_id, generics);

                        page.headers.insert(element_id, class.name);

                        thread.pages.insert(
                            page_id as u64,
                            thread::Page {
                                page_id: page_id as u64,
                                headers: child_headers,
                                heap: heap::Heap::new(),
                                stack: child_stack,
                                step: page_id as usize,
                            },
                        );

                        for item in class_items {
                            loop_item(thread, item, page_id as u64);
                        }
                        Some((element_id, class.public))
                    }
                    None => panic!("CANNOT FIND PAGE"),
                },
                definite::items::Collecting::Constructor(_) => {
                    std::println!("'Constructor' NOT YET IMPLEMENTED");
                    None
                }
                definite::items::Collecting::Caller(_) => {
                    std::println!("'Caller' NOT YET IMPLEMENTED");
                    None
                }
                definite::items::Collecting::Getter(_) => {
                    std::println!("'Getter' NOT YET IMPLEMENTED");
                    None
                }
                definite::items::Collecting::Setter(_) => {
                    std::println!("'Setter' NOT YET IMPLEMENTED");
                    None
                }
                definite::items::Collecting::NativeClass => {
                    std::println!("'NativeClass' NOT YET IMPLEMENTED");
                    None
                }
                definite::items::Collecting::ValueCall(_) => {
                    std::println!("'ValueCall' NOT YET IMPLEMENTED");
                    None
                }
                definite::items::Collecting::Enum(_) => {
                    std::println!("'Enum' NOT YET IMPLEMENTED");
                    None
                }
                definite::items::Collecting::NativeFunction(_) => {
                    std::println!("'NativeFunction' NOT YET IMPLEMENTED");
                    None
                }
                _ => None, //Ignore rest of the elements, because they do not have a corresponding task to do
            }
        }
