            if letter_char == "]" {
                if data.comma {
                    errors.push(error::Error {
                        debug_message: "\\src\\mapper\\value_collector.rs:290:0".to_string(),
                        title: error::errorList::error_s1.title.clone(),
                        code: error::errorList::error_s1.code,
                        message: error::errorList::error_s1.message.clone(),
                        builded_message: error::Error::build(
                            error::errorList::error_s1.message.clone(),
                            vec![error::ErrorBuildField {
                                key: "token".to_string(),
                                value: letter_char.to_string(),
                            }],
                        ),
                        pos: mapper::defs::Cursor {
                            range_start: pos.clone(),
                            range_end: pos.clone().skipChar(1),
                        },
                    });
                } else if !data.clone().collective[last_entry - 1].value.is_array_complete() {
                    if let types::Types::Array(adata) = &mut *data.collective[last_entry - 1].value
                    {
                        adata.complete = true;
                    }
                } else {
                    data.complete = true;
                }
            } else if letter_char == "," {
                if data.complete {
                    errors.push(error::Error {
                        debug_message: "\\src\\mapper\\value_collector.rs:320:0".to_string(),
                        title: error::errorList::error_s1.title.clone(),
                        code: error::errorList::error_s1.code,
                        message: error::errorList::error_s1.message.clone(),
                        builded_message: error::Error::build(
                            error::errorList::error_s1.message.clone(),
                            vec![error::ErrorBuildField {
                                key: "token".to_string(),
                                value: letter_char.to_string(),
                            }],
                        ),
                        pos: mapper::defs::Cursor {
                            range_start: pos.clone(),
                            range_end: pos.clone().skipChar(1),
                        },
                    });
                } else if data.comma {
                    errors.push(error::Error {
                        debug_message: "\\src\\mapper\\value_collector.rs:338:0".to_string(),
                        title: error::errorList::error_s1.title.clone(),
                        code: error::errorList::error_s1.code,
                        message: error::errorList::error_s1.message.clone(),
                        builded_message: error::Error::build(
                            error::errorList::error_s1.message.clone(),
                            vec![error::ErrorBuildField {
                                key: "token".to_string(),
                                value: letter_char.to_string(),
                            }],
                        ),
                        pos: mapper::defs::Cursor {
                            range_start: pos.clone(),
                            range_end: pos.clone().skipChar(1),
                        },
                    });
                } else {
                    if data.clone().collective[last_entry - 1].value.is_array() {
                        if let types::Types::Array(adata) = &mut *data.collective[last_entry - 1].value
                        {
                            /*
                            if adata.complete {
                                errors.push(error::Error {
                                    debug_message: "\\src\\mapper\\value_collector.rs:361:0"
                                        .to_string(),
                                    title: error::errorList::error_s1.title.clone(),
                                    code: error::errorList::error_s1.code,
                                    message: error::errorList::error_s1.message.clone(),
                                    builded_message: error::Error::build(
                                        error::errorList::error_s1.message.clone(),
                                        vec![error::ErrorBuildField {
                                            key: "token".to_string(),
                                            value: letter_char.to_string(),
                                        }],
                                    ),
                                    pos: mapper::defs::Cursor {
                                        range_start: pos.clone(),
                                        range_end: pos.clone().skipChar(1),
                                    },
                                });
                            } else 
                            */

                            if adata.comma {
                                errors.push(error::Error {
                                    debug_message: "\\src\\mapper\\value_collector.rs:380:0"
                                        .to_string(),
                                    title: error::errorList::error_s1.title.clone(),
                                    code: error::errorList::error_s1.code,
                                    message: error::errorList::error_s1.message.clone(),
                                    builded_message: error::Error::build(
                                        error::errorList::error_s1.message.clone(),
                                        vec![error::ErrorBuildField {
                                            key: "token".to_string(),
                                            value: letter_char.to_string(),
                                        }],
                                    ),
                                    pos: mapper::defs::Cursor {
                                        range_start: pos.clone(),
                                        range_end: pos.clone().skipChar(1),
                                    },
                                });
                            } else {
                                adata.comma = true;
                                adata.collective.push(types::ArrayEntry::default());
                            }
                        }
                    } else {
                        data.comma = true;
                        data.collective.push(types::ArrayEntry::default());
                    }
                }
            } else {
                data.comma = false;
                let mut will_be_itered = if (data.collective.len() == 0) {
                    variable::VariableCollector::default()
                } else {
                    variable::VariableCollector {
                        value: *data.collective[data.collective.len() - 1].value.clone(),
                        ..variable::VariableCollector::default()
                    }
                };
                let itered_array_vector = Box::new(collect(
                    &mut will_be_itered,
                    letter_char.clone(),
                    next_char.to_string().clone(),
                    last_char.to_string().clone(),
                    mapper::defs::CursorPosition(0, 0),
                ));
                let itered_entry = match itered_array_vector.itered_data.value {
                    types::Types::Number(match_data) => types::ArrayEntry {
                        value_complete: match_data.complete,
                        raw_value: String::new(),
                        value: Box::new(types::Types::Number(match_data)),
                    },
                    types::Types::Double(match_data) => types::ArrayEntry {
                        value_complete: match_data.complete,
                        raw_value: String::new(),
                        value: Box::new(types::Types::Double(match_data)),
                    },
                    types::Types::Bool(match_data) => types::ArrayEntry {
                        value_complete: true,
                        raw_value: String::new(),
                        value: Box::new(types::Types::Bool(match_data)),
                    },
                    types::Types::String(match_data) => types::ArrayEntry {
                        value_complete: match_data.complete,
                        raw_value: String::new(),
                        value: Box::new(types::Types::String(match_data)),
                    },
                    types::Types::Collective(match_data) => types::ArrayEntry {
                        value_complete: true,
                        raw_value: String::new(),
                        value: Box::new(types::Types::Null),
                    },
                    types::Types::Refference(match_data) => types::ArrayEntry {
                        value_complete: true,
                        raw_value: String::new(),
                        value: Box::new(types::Types::Null),
                    },
                    types::Types::Array(match_data) => types::ArrayEntry {
                        value_complete: false,
                        raw_value: String::new(),
                        value: Box::new(types::Types::Array(match_data)),
                    },
                    types::Types::Function => types::ArrayEntry {
                        value_complete: true,
                        raw_value: String::new(),
                        value: Box::new(types::Types::Null),
                    },
                    types::Types::Null => types::ArrayEntry {
                        value_complete: true,
                        raw_value: String::new(),
                        value: Box::new(types::Types::Null),
                    },
                };
                if (data.collective.len() == 0) {
                    data.collective.push(itered_entry);
                } else {
                    data.collective[last_entry - 1] = itered_entry;
                }
            }
